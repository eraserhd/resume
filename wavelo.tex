\def\company{Wavelo}
\def\position{Principal Software Engineer}
\relevantskill{Go}{nexus,coresystems}
\relevantskill{Python}{cronosysprojects,coresystems}
\relevantskill{Event-Driven Architecture}{points,nexus,coresystems}
\relevantskill{React}{centralpark,passport,coresystems}
\relevantskill{Mentoring}{xpay,centralpark,nexus}
\relevantskill{Technical Direction}{whitepaper,guided}
\relevantskill{Scalable Systems}{nexus,points}
\def\coverbody{
  Hello!

  I'm a hands-on (read: coding) Principal Engineer who's mentored and brought up several teams,
  facilitated architecture, given talks, and pushed organizations to align their structure
  with their technical goals.

  On tech stack, I'm expert-level in Go, familiar with Temporal, and passable in Python.  I'm
  competent on React-based front-end projects.  I'm deeply knowledgable about Docker and
  Kubernetes, having implemented the full CI/CD architecture for a codebase that I inherited
  in order to enable teams to deploy independently.

  On the "multiple programming languages": my early career hobby, starting in 2000, involved
  learning everything from Erlang to Prolog to Scheme to Haskell to Ruby and everything in between.
  This is aside from large base fluency in C/C++, Java, and Go.
  While I can't say I'm competent in all of these at the moment, I can say that I can relearn
  competency in any of them quickly.

  Regarding functional reactive programming, I view this (in the sense of the word commonly
  used today, not Conal Elliot's original idea, as mad he may be about it) as a fundamental pattern
  that arises when good functional practices are applied consistently.  I've used it not just
  in React frontends, or in Elm, but in building the Points system backend.

  I'd love a chance to talk about this position!
}
